name: Auto-merge Version Packages PR

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: write
  pull-requests: write
  checks: read

jobs:
  validate-and-merge:
    if: github.event.pull_request.title == 'Version Packages'
    runs-on: ubuntu-latest
    # Ceiling for the entire job, aligned with the checks wait below
    timeout-minutes: 15
    steps:
      - name: Checkout PR HEAD (no credentials)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0
          persist-credentials: false

      - name: Validate Version Packages PR contents
        shell: bash
        run: |
          set -euo pipefail
          BASE_SHA='${{ github.event.pull_request.base.sha }}'
          HEAD_SHA='${{ github.event.pull_request.head.sha }}'
          echo "Validating changed files are limited to allowed paths..."
          mapfile -t files < <(git diff --name-only "$BASE_SHA" "$HEAD_SHA")
          allowed='^(package.json|pnpm-lock.yaml|packages/.+/(package.json|CHANGELOG.md)|\\.changeset/.*)$'
          for f in "${files[@]}"; do
            if ! [[ "$f" =~ $allowed ]]; then
              echo "Unexpected file change in Version Packages PR: $f" >&2
              exit 1
            fi
          done

          echo "Checking that each changed package.json includes a version change..."
          for pj in $(git diff --name-only "$BASE_SHA" "$HEAD_SHA" -- "**/package.json"); do
            git diff "$BASE_SHA" "$HEAD_SHA" -- "$pj" | grep '"version"' >/dev/null || { echo "No version change in $pj" >&2; exit 1; }
          done

      - name: Wait for required checks (tests) to pass
        id: wait_checks
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const sha = context.payload.pull_request.head.sha;
            const deadline = Date.now() + 15 * 60 * 1000; // 15 minutes

            function pickTestRuns(checkRuns) {
              // Our required checks are the matrix test jobs named like: "Test (Node 20.x)"
              return checkRuns.filter(cr => cr.name && cr.name.startsWith('Test (Node '));
            }

            async function getTestStatus() {
              const { data } = await github.rest.checks.listForRef({ owner, repo, ref: sha, per_page: 100 });
              const tests = pickTestRuns(data.check_runs);
              if (tests.length === 0) return { present: false };
              const incomplete = tests.filter(cr => cr.status !== 'completed');
              const failed = tests.filter(cr => cr.status === 'completed' && cr.conclusion !== 'success');
              if (failed.length > 0) return { present: true, complete: true, success: false, details: failed.map(f => `${f.name}:${f.conclusion}`) };
              if (incomplete.length > 0) return { present: true, complete: false };
              // All completed: ensure all succeeded
              const notSuccess = tests.filter(cr => cr.conclusion !== 'success');
              return { present: true, complete: true, success: notSuccess.length === 0 };
            }

            core.info('Waiting for required test checks to succeed...');
            while (Date.now() < deadline) {
              const status = await getTestStatus();
              if (!status.present) {
                core.info('No test checks found yet; sleeping 10s...');
                await new Promise(r => setTimeout(r, 10_000));
                continue;
              }
              if (!status.complete) {
                core.info('Tests still running; sleeping 15s...');
                await new Promise(r => setTimeout(r, 15_000));
                continue;
              }
              if (status.success) {
                core.info('All required test checks succeeded.');
                return;
              }
              core.setFailed('One or more required test checks failed.');
              return;
            }
            core.setFailed('Timed out waiting for required test checks.');

      - name: Check PR mergeability
        id: gate
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const number = context.payload.pull_request.number;
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: number });
            if (pr.base.ref !== 'main') {
              core.setFailed(`PR targets ${pr.base.ref}, expected main`);
              return;
            }
            const isInternal = pr.head.repo.full_name === `${owner}/${repo}`;
            const isBot = pr.user.login === 'github-actions[bot]';
            if (!isInternal || !isBot) {
              core.info('Not an internal Version Packages PR by GitHub Actions bot; skipping auto-merge.');
              core.setOutput('should_merge', 'false');
              return;
            }
            if (pr.draft) {
              core.info('PR is draft; will not merge yet.');
              core.setOutput('should_merge', 'false');
              return;
            }
            // Poll for a definitive mergeable_state and require 'clean'
            let attempts = 0;
            let latest;
            while (attempts < 10) {
              ({ data: latest } = await github.rest.pulls.get({ owner, repo, pull_number: number }));
              if (latest.mergeable_state && latest.mergeable_state !== 'unknown') {
                break;
              }
              await new Promise(r => setTimeout(r, 3000));
              attempts++;
            }
            if (!latest || !latest.mergeable_state || latest.mergeable_state === 'unknown') {
              core.info('mergeable_state is still unknown after polling; not merging.');
              core.setOutput('should_merge', 'false');
              return;
            }
            if (latest.mergeable_state !== 'clean') {
              core.info(`mergeable_state=${latest.mergeable_state}; not merging.`);
              core.setOutput('should_merge', 'false');
              return;
            }
            core.setOutput('should_merge', 'true');

      - name: Merge Version Packages PR
        if: steps.gate.outputs.should_merge == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
              merge_method: 'squash',
            });
            core.info('Merged Version Packages PR.');
